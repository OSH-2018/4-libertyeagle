# OSH Lab 4 - 实现Meltdown内存越权访问
## 实验概述
本实验皆在实现利用Meltdown漏洞实现内存越权访问，获取处在用户空间的进程本不允许访问的内核空间的内存内容。
Meltdown漏洞与2017年7月被发现，并于2018年1月公开，其历史甚至可以追溯到1995年，一篇名为*The Intel 80x86 Processor Architecture: Pitfalls for Secure Systems*的论文就警告了利用CPU的cache和TLB实现攻击的可能性。该漏洞波及范围很广，影响了所有Intel x86架构的处理器，IBM POWER处理器，以及部分ARM架构的处理周期。该漏洞也是个硬件漏洞，目前操作系统厂商发布的安全补丁也会导致处理器性能5%-10%的降低。简单来说，Meltdown主要利用的就是在现代CPU中的乱序执行（Out-of-order execution），其利用了一个race condition，这个race condition在CPU内存访问和内存权限检查时发生。现代CPU在分支指令实际被计算出是否进行分支之前就已经将接下来不涉及到数据依赖的指令提前装载进流水线中执行，如果CPU最后发现分支预测错误，那么CPU将会清除掉这几条指令，将处理器的微结构恢复到之前的状态。但是，处理器的状态（例如cache）却没有完全被恢复，从而可以被利用来进行越权内存访问。
## Meltdown背景知识
### CPU乱序执行
乱序执行是现代CPU一种提高CPU吞吐量的方法，CPU会在确定什么指令一定需要被执行且提交之前就预测性地执行一些指令。在Intel Skylake构架中，流水线由Frontend, Execution Engine和Memory Subsystem组成。
机器指令首先由Frontend从内存中读取并且解码成微指令。乱序执行主要由Execution Engine完成，其含有一个Reorder buffer负责对寄存器的重定向。可以给指令分配寄存器，重命名寄存器以使得指令可以提前用到未被提交的寄存器的值。之后指令会由调度器Scheduler分配到合适的执行单元执行。如果寄存器的值不可用，或者没有空闲的执行单元可用，那么指令就会在流水线中等待，直到可以被执行为止。   
CPU通常采用静态分支预测（分支预测的结果完全取决于指令本身）或动态分支预测。动态分支预测维持一个分支预测计数器，以更好的识别出程序中的分支模式。
### 地址空间
现代操作系统通常都采用虚拟内存机制，以提供比实际物理内存更大的地址空间，以及实现权限控制。在Linux中，虚拟内存空间被分成了用户态内存空间和内核态内存空间，用户空间无法访问内核空间的内容。系统通过在页表中设置一个权限位，CPU仅有处在特权模式（privileged mode）时能访问内核空间。上下文切换时相应的页表也要切换。Linux中，通常整个物理地址都会被映射到内核空间。因此，只要我们的攻击进程能访问自身的内核地址空间，我们就几乎能访问到任何我们想要得到的数据。
### cache攻击
Flush+Reload是一种较为常用的cache攻击，它拥有低噪声以及较好的性能。Flush+Reload攻击的方式主要是攻击者频繁地用`cflush`指令清空目标内存空间，从cache中抹除，这样的话其他进程访问该内存空间的话就需要重新载入cache。此时，攻击者进程在依次访问目标内存空间的每一个地址，测量平均访问时间。耗时明显小的显然是被载入cache的，而访问时间长的则没有被载入cache。因此我们便利用了cache中的信息得到了其他进程的内存访问信息。
